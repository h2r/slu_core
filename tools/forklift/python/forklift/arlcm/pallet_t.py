"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

import cStringIO as StringIO
import struct

import pallet_enum_t

import pallet_slot_pair_t

class pallet_t(object):
    __slots__ = ["utime", "id", "relative_to_id", "pos", "orientation", "bbox_min", "bbox_max", "pallet_type", "num_slot_pairs", "slot_pairs", "utime_updated", "last_updated_by", "approach_lat", "approach_lon", "approach_theta", "label"]

    REAQUISITION = 0x0000000000000001
    LIDAR = 0x0000000000000002
    UI = 0x0000000000000004
    MANIPULATION = 0x0000000000000008
    SIM = 0x0000000000000010
    ALL = 0xffffffffffffffff
    REAQ_REPLACE = 100000000
    LABEL_NONE = 0
    LABEL_BRICKS = 1
    LABEL_EMPTY_WOODEN = 2
    LABEL_ENGINE = 3
    LABEL_FENCING = 4
    LABEL_FENDER = 5
    LABEL_GENERATOR = 6
    LABEL_GENERATOR_ACCESSORIES = 7
    LABEL_GRAPPLE = 8
    LABEL_GRILL = 9
    LABEL_HEATER = 10
    LABEL_HOOD_ASSEMBLY = 11
    LABEL_HOPPERS = 12
    LABEL_INTERT_AMMO = 13
    LABEL_JMIC = 14
    LABEL_MACHINE_GUN_MOUNTS = 15
    LABEL_MACHINE_GUN_RACKET_SYSTEM = 16
    LABEL_POP_ASSEMBLY = 17
    LABEL_PUMP_ASSEMBLY = 18
    LABEL_REFRIGERATOR = 19
    LABEL_TIRE = 20
    LABEL_TIRE_ASSEMBLY = 21
    LABEL_TIRES = 22
    LABEL_TRAILER_CHASSIS = 23
    LABEL_TRANSMISSION = 24
    LABEL_WASHING_MACHINE = 25

    def __init__(self):
        self.utime = 0
        self.id = 0
        self.relative_to_id = 0
        self.pos = [ 0.0 for dim0 in range(3) ]
        self.orientation = [ 0.0 for dim0 in range(4) ]
        self.bbox_min = [ 0.0 for dim0 in range(3) ]
        self.bbox_max = [ 0.0 for dim0 in range(3) ]
        self.pallet_type = None
        self.num_slot_pairs = 0
        self.slot_pairs = []
        self.utime_updated = 0
        self.last_updated_by = 0
        self.approach_lat = 0.0
        self.approach_lon = 0.0
        self.approach_theta = 0.0
        self.label = 0

    def encode(self):
        buf = StringIO.StringIO()
        buf.write(pallet_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">qqq", self.utime, self.id, self.relative_to_id))
        buf.write(struct.pack('>3d', *self.pos[:3]))
        buf.write(struct.pack('>4d', *self.orientation[:4]))
        buf.write(struct.pack('>3d', *self.bbox_min[:3]))
        buf.write(struct.pack('>3d', *self.bbox_max[:3]))
        self.pallet_type._encode_one(buf)
        buf.write(struct.pack(">i", self.num_slot_pairs))
        for i0 in range(self.num_slot_pairs):
            self.slot_pairs[i0]._encode_one(buf)
        buf.write(struct.pack(">qqdddi", self.utime_updated, self.last_updated_by, self.approach_lat, self.approach_lon, self.approach_theta, self.label))

    def decode(data):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = StringIO.StringIO(data)
        if buf.read(8) != pallet_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return pallet_t._decode_one(buf)
    decode = staticmethod(decode)

    def _decode_one(buf):
        self = pallet_t()
        self.utime, self.id, self.relative_to_id = struct.unpack(">qqq", buf.read(24))
        self.pos = struct.unpack('>3d', buf.read(24))
        self.orientation = struct.unpack('>4d', buf.read(32))
        self.bbox_min = struct.unpack('>3d', buf.read(24))
        self.bbox_max = struct.unpack('>3d', buf.read(24))
        self.pallet_type = pallet_enum_t.pallet_enum_t._decode_one(buf)
        self.num_slot_pairs = struct.unpack(">i", buf.read(4))[0]
        self.slot_pairs = []
        for i0 in range(self.num_slot_pairs):
            self.slot_pairs.append(pallet_slot_pair_t.pallet_slot_pair_t._decode_one(buf))
        self.utime_updated, self.last_updated_by, self.approach_lat, self.approach_lon, self.approach_theta, self.label = struct.unpack(">qqdddi", buf.read(44))
        return self
    _decode_one = staticmethod(_decode_one)

    _hash = None
    def _get_hash_recursive(parents):
        if pallet_t in parents: return 0
        newparents = parents + [pallet_t]
        tmphash = (0xd8561dfd905a0a1e+ pallet_enum_t.pallet_enum_t._get_hash_recursive(newparents)+ pallet_slot_pair_t.pallet_slot_pair_t._get_hash_recursive(newparents)) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff 
        return tmphash
    _get_hash_recursive = staticmethod(_get_hash_recursive)
    _packed_fingerprint = None
    
    def _get_packed_fingerprint():
        if pallet_t._packed_fingerprint is None:
            pallet_t._packed_fingerprint = struct.pack(">Q", pallet_t._get_hash_recursive([]))
        return pallet_t._packed_fingerprint
    _get_packed_fingerprint = staticmethod(_get_packed_fingerprint)

