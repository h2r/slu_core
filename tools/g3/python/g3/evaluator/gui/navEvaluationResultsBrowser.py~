import matplotlib_qt
from environ_vars import SLU_HOME
from subprocess import Popen
import shlex
import lcm
import sys
import signal
from PyQt4.QtGui import QMainWindow
from PyQt4.QtCore import SIGNAL, QSocketNotifier
import pylab as mpl
from corpusMturk import readCorpus
import basewindow
import evaluationResultsBrowser_ui
import evaluationResultsModel as resultsModel
from forklift.gui import costFunctionBrowser

from nlu_navigation.mapping.semanticMap import SemanticMap
from nlu_navigation.mapping.carmenSemanticMap import CarmenSemanticMap
from environ_vars import SLU_HOME
from nlu_navigation.gui.navigationBrowserTools import NavigationBrowserTools
from forklift import actionMap, esdcSearch, state_extractor
from forklift import cost_function_crf as cf
from rndf_util import rndf
from dataEvaluation.evaluateCorpus import ResultsFile, EvaluationResult
from forklift.gui.plansModel import Plan
import os
import time

class MainWindow(QMainWindow, evaluationResultsBrowser_ui.Ui_MainWindow):
    def cleanup(self):
        self.agileRun.cleanup()
        sys.exit(1)

    def mpl_draw(self):
        self.restoreLimits()
        self.figure.canvas.draw()

    def __init__(self):
        QMainWindow.__init__(self)
        self.setupUi(self)

        self.taskPlanner = esdcSearch.BeamSearch(cf.CostFnCrf)

        self.cfBrowser = costFunctionBrowser.MainWindow(NavigationBrowserTools(),
                                                        self.taskPlanner,
                                                        initialState=False)
        self.cfBrowser.setWindowTitle(str(self.cfBrowser.windowTitle()) +
                                      " (Evaluation Results Browser)")
        self.cfBrowser.show()

        self.figure = mpl.figure()
        self.axes = self.figure.gca()
        
        self.limits = [10, 40, 10, 40]
        self.restoreLimits()
        self.figure.canvas.mpl_connect('draw_event', self.updateLimits)
        
        self.resultsModel = resultsModel.Model(self.resultsTable)
            
        self.model = None
        self.dataset = None

        self.socket = QSocketNotifier(self.lcm.fileno(),
                                      QSocketNotifier.Read)
        
        self.connect(self.socket,
                     SIGNAL("activated(int)"),
                     self.socketActivated)    

        self.connect(self.resultsTable.selectionModel(),
                     SIGNAL("selectionChanged ( QItemSelection, QItemSelection )"),
                     self.selectResult)

        self.connect(self.sendToCostFunctionBrowserButton,
                     SIGNAL("clicked()"),
                     self.sendToCostBrowser)

        self.connect(self.esdcFilter,
                     SIGNAL("editingFinished()"),
                     self.filterEsdcs)

        
        print "adding export button"
        self.connect(self.exportButton,
                     SIGNAL("clicked()"),
                     self.sendToClipboard)


        self.resultsTable.selectRow(0)

        signal.signal (signal.SIGINT, lambda *s: self.cleanup())
                            
    def sendToClipboard(self):
        print "calling send to clipboard"
        self.resultsModel.sendToClipboard()

    def socketActivated(self, arg):
        self.lcm.handle()

    def sendToCostBrowser(self):
        '''send a command to the cost function browser'''
        
        # selectedData may return multiple selections
        # as a hack, we'll just operate on the first one
        selectedResults = self.resultsModel.selectedData()

        selectedResult = selectedResults[0]
        
#        print "Number of results: ",len(selectedResults)#1    

        esdcs = selectedResult.esdcs
        command = selectedResult.text
        result = selectedResult.result

        self.cfBrowser.updateEsdcs(esdcs)
        self.cfBrowser.updateCommand(command)

        def result_to_plan(res):
            return Plan(res.plan,res.cost)

        #get full sequence
        sequence = []
        currAnnotation = result.plan
        while currAnnotation:
            sequence = currAnnotation.getGroundings("sequence")[0] + sequence
            currAnnotation = currAnnotation.priorAnnotation
        
        result.plan.setGrounding("sequence", sequence)
            
        self.cfBrowser.updateState(sequence[0][0])
        
        planList = map(result_to_plan,selectedResults[0].results)
        self.plans = planList
        self.cfBrowser.plans = planList
        self.cfBrowser.plansDict = {selectedResult.esdcs[-1]:planList}
        
        self.cfBrowser.plansModel.setData(planList)
        self.cfBrowser.plansView.selectRow(0)
        self.cfBrowser.draw()

    def filterEsdcs(self):
        expr = self.esdcFilter.text()
        print expr
        try:
            filterFunction = eval(str(expr))
        except:
            raise
        self.resultsModel.setFilter(filterFunction)

    def selectResult(self, newSelection, oldSelection):
        print "selecting results"
        selectedResults = self.resultsModel.selectedData()
        selectedResult = selectedResults[0]

        start, end = selectedResult.esdcs.range
        entireText = selectedResult.esdcs.entireText
        labelText = (entireText[0:start]+ 
                     "<b>" + entireText[start:end] + "</b>" +
                     entireText[end:])
        self.entireEsdcText.setText(labelText)

        self.commandText.setText(selectedResult.text)
        
    def load(self, dataset_fname, results_fname):
        self.resultsFile = ResultsFile(dataset_fname, results_fname)

        self.agileRunSummaryLog = os.path.dirname(results_fname) + "/" + \
            "agile_run_summary_log.txt"
        if (os.path.exists(self.agileRunSummaryLog) == False):
            f = open (self.agileRunSummaryLog, 'w')
            f.write('# ' + results_fname + '\n')
            f.write('# EvaluationTimeSec LCMCommandLog\n')
            f.close()
        self.setWindowTitle("Evaluation Results Browser: " + results_fname)
        
        self.resultsModel.setData(self.resultsFile)
        
    def updateLimits(self, mplEvent):
        self.saveLimits()
    def saveLimits(self):
        self.limits = self.axes.axis()
    def restoreLimits(self):
        if self.limits != None:
            self.axes.axis(self.limits)

        
def main(argv):
    app = basewindow.makeApp()

    from sys import argv
    
    wnd = MainWindow()
    print "loading"
    wnd.load(argv[1], argv[2])
    print "showing"
    wnd.show()

    app.exec_()

if __name__=="__main__":
    main(sys.argv)

 
